<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>zen.graph.Graph</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="zen-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://www.ruthsresearch.org/static/zen/pydoc">Zen</a></th>
          </tr></table></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="zen-module.html">Package&nbsp;zen</a> ::
        <a href="zen.graph-module.html">Module&nbsp;graph</a> ::
        Class&nbsp;Graph
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options">[<a href="javascript:void(0);" class="privatelink"
    onclick="toggle_private();">hide&nbsp;private</a>]</span></td></tr>
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="zen.graph.Graph-class.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== CLASS DESCRIPTION ==================== -->
<h1 class="epydoc">Class Graph</h1><p class="nomargin-top"></p>
<pre class="base-tree">
object --+
         |
        <strong class="uidshort">Graph</strong>
</pre>

<dl><dt>Known Subclasses:</dt>
<dd>
      <ul class="subclass-list">
<li><a href="zen.bipartite.BipartiteGraph-class.html">bipartite.BipartiteGraph</a></li>  </ul>
</dd></dl>

<hr />
<pre class="literalblock">

This class provides a highly-optimized implementation of an `undirected graph &lt;http://en.wikipedia.org/wiki/Undirected_graph#Undirected_graph&gt;`_. 
Duplicate edges are not allowed.

Public properties include:

        * ``max_node_index`` (int): the largest node index currently in use
        * ``max_edge_index`` (int): the largest edge index currently in use
        * ``edge_list_capacity`` (int): the initial number of edge positions that will be allocated in a newly created node's edge list.
        * ``node_grow_factor`` (int): the multiple by which the node storage array will grow when its capacity is exceeded.
        * ``edge_grow_factor`` (int): the multiple by which the edge storage array will grow when its capacity is exceeded.
        * ``edge_list_grow_factor`` (int): the multiple by which the a node's edge list storage array will grow when its capacity is exceeded.
        
**Graph Listeners**:

Instances of a graph can notify one or more listeners of changes to it.  Listeners should support the following methods:

        * ``node_added(nidx,nobj,data)``
        * ``node_removed(nidx,nobj)``
        * ``edge_added(eidx,uidx,vidx,data,weight)``
        * ``edge_removed(eidx,uidx,vidx)``
        
Other event notifications are possible (changes to data, etc...).  These will be supported in future versions.

It is noteworthy that adding listeners imposes a serious speed limitation on graph building functions.  If no listeners
are present in the graph, then node/edge addition/removal proceed as fast as possible.  Notifying listeners requires 
these functions to follow non-optimal code paths.

</pre>

<!-- ==================== INSTANCE METHODS ==================== -->
<a name="section-InstanceMethods"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Instance Methods</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-InstanceMethods"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="__contains__"></a><span class="summary-sig-name">__contains__</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return ``True`` if object ``nobj`` is associated with a node in this 
      graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="__getitem__"></a><span class="summary-sig-name">__getitem__</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Get the data for the node associated with ``nobj``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="__getstate__"></a><span class="summary-sig-name">__getstate__</span>(<span class="summary-sig-arg">...</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#__init__" class="summary-sig-name">__init__</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Create a new :py:class:`Graph` object.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="__len__"></a><span class="summary-sig-name">__len__</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the number of nodes in the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">a new object with type S, a subtype of T</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#__new__" class="summary-sig-name">__new__</a>(<span class="summary-sig-arg">T</span>,
        <span class="summary-sig-arg">S</span>,
        <span class="summary-sig-arg">...</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#__reduce__" class="summary-sig-name">__reduce__</a>(<span class="summary-sig-arg">...</span>)</span><br />
      helper for pickle</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="__setstate__"></a><span class="summary-sig-name">__setstate__</span>(<span class="summary-sig-arg">...</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#add_edge" class="summary-sig-name">add_edge</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Add an edge to the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#add_edge_" class="summary-sig-name">add_edge_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Add an edge to the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#add_edge_x" class="summary-sig-name">add_edge_x</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Adds an edge to the graph with a specific edge index.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="add_listener"></a><span class="summary-sig-name">add_listener</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Add a listener to the graph that will be notified of all changes to 
      the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#add_node" class="summary-sig-name">add_node</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Add a node to this graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#add_node_x" class="summary-sig-name">add_node_x</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Adds a node to the graph with a specific node index.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#add_nodes" class="summary-sig-name">add_nodes</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Add a specified set of nodes to the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#compact" class="summary-sig-name">compact</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Compact the graph in place.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#copy" class="summary-sig-name">copy</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Create a copy of this graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="degree"></a><span class="summary-sig-name">degree</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the degree of node with object ``nobj``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="degree_"></a><span class="summary-sig-name">degree_</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the degree of node with index ``nidx``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="edge_data"></a><span class="summary-sig-name">edge_data</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the data associated with the edge between ``u`` and ``v`` 
      (node objects).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="edge_data_"></a><span class="summary-sig-name">edge_data_</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the data associated with the edge with index ``eidx``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="edge_idx"></a><span class="summary-sig-name">edge_idx</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the edge index for the edge between ``u`` and ``v`` (node 
      objects).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="edge_idx_"></a><span class="summary-sig-name">edge_idx_</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the edge index for the edge between ``u`` and ``v`` (node 
      indices).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#edges" class="summary-sig-name">edges</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return a list of edges in the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#edges_" class="summary-sig-name">edges_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return a ``numpy.ndarray`` containing edges in the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#edges_iter" class="summary-sig-name">edges_iter</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return an iterator over edges in the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#edges_iter_" class="summary-sig-name">edges_iter_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return an iterator over edges in the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#endpoint" class="summary-sig-name">endpoint</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the object for the node (not u) that is the endpoint of this edge.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#endpoint_" class="summary-sig-name">endpoint_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the index for the node (not u) that is the endpoint of this edge.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="endpoints"></a><span class="summary-sig-name">endpoints</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the node objects at the endpoints of the edge with index 
      ``eidx``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="endpoints_"></a><span class="summary-sig-name">endpoints_</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the node indices at the endpoints of the edge with index 
      ``eidx``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#grp_edges_iter" class="summary-sig-name">grp_edges_iter</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return an iterator over the edges of a group of nodes.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#grp_edges_iter_" class="summary-sig-name">grp_edges_iter_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return an iterator over edges incident to some nodes in the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#grp_neighbors_iter" class="summary-sig-name">grp_neighbors_iter</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return an iterator over a group of nodes' immediate neighbors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#grp_neighbors_iter_" class="summary-sig-name">grp_neighbors_iter_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return an iterator over a group of nodes' immediate neighbors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#has_edge" class="summary-sig-name">has_edge</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return ``True`` if the graph contains an edge between ``u`` and ``v``
      (node objects).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#has_edge_" class="summary-sig-name">has_edge_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return ``True`` if the graph contains an edge between ``u`` and ``v`` (node indices).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#is_compact" class="summary-sig-name">is_compact</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return ``True`` if the graph is in compact form.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="is_directed"></a><span class="summary-sig-name">is_directed</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return ``True`` if this graph is directed (which it is not).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="is_valid_node_idx"></a><span class="summary-sig-name">is_valid_node_idx</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return ``True`` if ``nidx`` is the index of a node in this graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#matrix" class="summary-sig-name">matrix</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Construct and return the adjacency matrix.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#neighbors" class="summary-sig-name">neighbors</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return a list of a node's immediate neighbors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#neighbors_" class="summary-sig-name">neighbors_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return an ``numpy.ndarray`` containing a node's immediate neighbors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#neighbors_iter" class="summary-sig-name">neighbors_iter</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return an iterator over a node's immediate neighbors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#neighbors_iter_" class="summary-sig-name">neighbors_iter_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return an iterator over a node's immediate neighbors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="node_data"></a><span class="summary-sig-name">node_data</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the data object associated with node having object identifier 
      ``nobj``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="node_data_"></a><span class="summary-sig-name">node_data_</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the data object associated with node having index ``nidx``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="node_idx"></a><span class="summary-sig-name">node_idx</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the index of the node with node object ``nobj``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#node_object" class="summary-sig-name">node_object</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the object associated with node having index ``nidx``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#nodes" class="summary-sig-name">nodes</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return a list of the node objects in the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#nodes_" class="summary-sig-name">nodes_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return a numpy array of the nodes.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#nodes_iter" class="summary-sig-name">nodes_iter</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return an iterator over all the nodes in the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#nodes_iter_" class="summary-sig-name">nodes_iter_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return an iterator over all the nodes in the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#rm_edge" class="summary-sig-name">rm_edge</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Remove the edge between node objects ``u`` and ``v``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#rm_edge_" class="summary-sig-name">rm_edge_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Remove the edge with index ``eidx``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="rm_listener"></a><span class="summary-sig-name">rm_listener</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Remove a listener so it will no longer be updated with changes to the
      graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#rm_node" class="summary-sig-name">rm_node</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Remove the node associated with node object ``nobj``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#rm_node_" class="summary-sig-name">rm_node_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Remove the node with index ``nidx``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#set_edge_data" class="summary-sig-name">set_edge_data</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Associate a data object with the edge between nodes ``u`` and ``v`` 
      (node objects).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#set_edge_data_" class="summary-sig-name">set_edge_data_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Associate a data object with the edge with index ``eidx``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#set_node_data" class="summary-sig-name">set_node_data</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Associate a new data object with a specific node in the network.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#set_node_data_" class="summary-sig-name">set_node_data_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Associate a new data object with a specific node in the network.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#set_node_object" class="summary-sig-name">set_node_object</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Change the node object associated with a specific node.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#set_node_object_" class="summary-sig-name">set_node_object_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Change the node object associated with a specific node.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="set_weight"></a><span class="summary-sig-name">set_weight</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Set the weight of the edge between nodes ``u`` and ``v`` (node 
      objects) to ``w``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="set_weight_"></a><span class="summary-sig-name">set_weight_</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Set the weight of the edge with index ``eidx`` to ``w``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="size"></a><span class="summary-sig-name">size</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the number of edges in the graph.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#validate" class="summary-sig-name">validate</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Checks whether the graph structure is valid.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="weight"></a><span class="summary-sig-name">weight</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the weight of the edge between nodes ``u`` and ``v`` (node 
      objects).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="weight_"></a><span class="summary-sig-name">weight_</span>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the weight of the edge with index ``eidx``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
  <tr>
    <td colspan="2" class="summary">
    <p class="indent-wrapped-lines"><b>Inherited from <code>object</code></b>:
      <code>__delattr__</code>,
      <code>__format__</code>,
      <code>__getattribute__</code>,
      <code>__hash__</code>,
      <code>__reduce_ex__</code>,
      <code>__repr__</code>,
      <code>__setattr__</code>,
      <code>__sizeof__</code>,
      <code>__str__</code>,
      <code>__subclasshook__</code>
      </p>
    </td>
  </tr>
</table>
<!-- ==================== STATIC METHODS ==================== -->
<a name="section-StaticMethods"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Static Methods</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-StaticMethods"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.graph.Graph-class.html#from_adj_matrix" class="summary-sig-name">from_adj_matrix</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Create a new :py:class:`Graph` from adjacency matrix information
contained in ``M``.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== PROPERTIES ==================== -->
<a name="section-Properties"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Properties</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Properties"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="edge_capacity"></a><span class="summary-name">edge_capacity</span>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="edge_grow_factor"></a><span class="summary-name">edge_grow_factor</span>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="edge_list_capacity"></a><span class="summary-name">edge_list_capacity</span>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="edge_list_grow_factor"></a><span class="summary-name">edge_list_grow_factor</span>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="graph_listeners"></a><span class="summary-name">graph_listeners</span>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="max_edge_idx"></a><span class="summary-name">max_edge_idx</span>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="max_node_idx"></a><span class="summary-name">max_node_idx</span>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="node_capacity"></a><span class="summary-name">node_capacity</span>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="node_grow_factor"></a><span class="summary-name">node_grow_factor</span>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="num_edges"></a><span class="summary-name">num_edges</span>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="num_graph_listeners"></a><span class="summary-name">num_graph_listeners</span>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="num_nodes"></a><span class="summary-name">num_nodes</span>
    </td>
  </tr>
  <tr>
    <td colspan="2" class="summary">
    <p class="indent-wrapped-lines"><b>Inherited from <code>object</code></b>:
      <code>__class__</code>
      </p>
    </td>
  </tr>
</table>
<!-- ==================== METHOD DETAILS ==================== -->
<a name="section-MethodDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Method Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-MethodDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="__init__"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">__init__</span>(<span class="sig-arg">...</span>)</span>
    <br /><em class="fname">(Constructor)</em>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Create a new :py:class:`Graph` object.

**Keyword Args**:

  * ``node_capacity [=100]`` (int): the initial number of nodes this graph has space to hold.
  * ``edge_capacity [=100]`` (int): the initial number of edges this graph has space to hold.
  * ``edge_list_capacity [=5]`` (int): the initial number of edges that each node is allocated space for initially.

</pre>
  <dl class="fields">
    <dt>Overrides:
        object.__init__
    </dt>
  </dl>
</td></tr></table>
</div>
<a name="__new__"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">__new__</span>(<span class="sig-arg">T</span>,
        <span class="sig-arg">S</span>,
        <span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  
  <dl class="fields">
    <dt>Returns: a new object with type S, a subtype of T</dt>
    <dt>Overrides:
        object.__new__
    </dt>
  </dl>
</td></tr></table>
</div>
<a name="__reduce__"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">__reduce__</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>helper for pickle</p>
  <dl class="fields">
    <dt>Overrides:
        object.__reduce__
        <dd><em class="note">(inherited documentation)</em></dd>
    </dt>
  </dl>
</td></tr></table>
</div>
<a name="add_edge"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">add_edge</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Add an edge to the graph.

As a convenience, if ``u`` or ``v`` are not valid node objects, they will be added to the graph
and then the edge will be added.::

        G = Graph()
        
        print len(G) # prints '0'
        G.add_edge(1,2) # First nodes 1 and 2 will be added, then the edge will be added
        print len(G) # prints '2' since there are now two nodes in the graph.
        
.. note::
        In undirected graphs, the edges (u,v) and (v,u) refer to the same edge.  Thus the following code
        will raise an error::
        
                G = Graph()
                G.add_edge(1,2)
                G.add_edge(2,1) # a ZenException will be raised because the edge already exists.
        

**Args**:

        * ``u``: one endpoint of the graph. 
        * ``v``: another endpoint of the graph.
        * ``data [=None]``: an optional data object to associate with the edge
        * ``weight [=1]`` (float): the weight of the edge.
        
**Returns**:
        ``integer``. The index for the newly created edge.
        
**Raises**:
        :py:exc:`ZenException`: if the edge already exists in the graph.
        

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="add_edge_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">add_edge_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Add an edge to the graph.

This version of the edge addition functionality uses node indices (not node objects).
Unlike in :py:method:``.add_edge``, if ``u`` or ``v`` are not valid node indices, then an
exception will be raised.
        
.. note::
        In undirected graphs, the edges (u,v) and (v,u) refer to the same edge.  Thus the following code
        will raise an error::
        
                G = Graph()
                n1 = G.add_node(1)
                n2 = G.add_node(2)
                G.add_edge_(n1,n2)
                G.add_edge(n2,n1) # a ZenException will be raised because the edge already exists.
        

**Args**:

        * ``u`` (int): one endpoint of the graph. This is a node index.
        * ``v`` (int): another endpoint of the graph. This is a node index.
        * ``data [=None]``: an optional data object to associate with the edge
        * ``weight [=1]`` (float): the weight of the edge.
        
**Returns**:
        ``integer``. The index for the newly created edge.
        
**Raises**:
        :py:exc:`ZenException`: if the edge already exists in the graph or if either of the node indices are invalid.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="add_edge_x"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">add_edge_x</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Adds an edge to the graph with a specific edge index.

This function permits very high-performance population of the graph data structure
with edges by allowing the calling function to specify the edge index of the edge being added.  
In general, this should only be done when the edge indices have been obtained from a previously 
stored graph data structure.

.. DANGER:: 
        This function should be used with great care because by specifying a edge index, the 
        calling function is forcing Zen to access specific parts of the memory allocated for edge.  
        Unless you are writing high-performance network loading code, you should not be calling
        this function directly.

        When used incorrectly, this method call can irreparably damage the integrity of the graph object, 
        leading to incorrect results or, more likely, segmentation faults.

**Args**:

        * ``eidx`` (int): the edge index this node should be assigned.
        * ``u`` (int): one endpoint of the edge. This is a node index.
        * ``v`` (int): the other endpoint of the edge. This is a node index.
        * ``nobj``: the node object that will be associated with this node.  If ``None``, then no object will be
                assigned to this node.
        * ``data``: the data object that will be associated with this node.  If ``None``, then no data will be 
                assigned to this node.
        
**Raises**:
        :py:exc:`ZenException`: if the edge already exists in the graph, the edge index is already in use, or either of the
        node indices are invalid.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="add_node"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">add_node</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Add a node to this graph.

**Args**:

        * ``nobj [=None]``: the (optional) object that will be a convenient identifier for this node.
        * ``data [=None]``: an optional data object to associated with this node.

**Returns**:
        ``int``. The index of the new node.
        
**Raises**:
        :py:exc:`ZenException`: if the node could not be added.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="add_node_x"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">add_node_x</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Adds a node to the graph with a specific node index.

This function permits very high-performance population of the graph data structure
with nodes by allowing the calling function to specify the node index and edge
capacity of the node being added.  In general, this should only be done when the node indices
have been obtained from a previously stored graph data structure.

.. DANGER:: 
        This function should be used with great care because by specifying a node index, the 
        calling function is forcing Zen to access specific parts of the memory allocated for nodes.  
        Unless you are writing high-performance network loading code, you should not be calling
        this function directly.
        
        When used incorrectly, this method call can irreparably damage the integrity of the graph object, 
        leading to incorrect results or, more likely, segmentation faults.
        
**Args**:

        * ``node_idx`` (int): the node index this node should be assigned.
        * ``edge_list_capacity`` (int): the number of entries that should be allocated in the edge list for this node.
        * ``nobj``: the node object that will be associated with this node.  If ``None``, then no object will be
                assigned to this node.
        * ``data``: the data object that will be associated with this node.  If ``None``, then no data will be 
                assigned to this node.
                
**Raises**:
        :py:exc:`ZenException`: if the node index is already in use or the node object is not unique.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="add_nodes"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">add_nodes</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Add a specified set of nodes to the graph.

**Args**:

        * ``num_nodes`` (int): the number of nodes to add to the graph.
        * ``node_obj_fxn [=None]`` (callable): a callable object (typically a function) that accepts a node index (an integer)
                and returns the object that will be used as the object for that node in the graph.  If this is not specified, then 
                no node objects will be assigned to nodes.
                
**Returns**:
        ``np.ndarray[int,ndims=1]``, ``I``. The node indices of the nodes added where ``I[j]`` is the index of the jth node added by this
        function call.
        
**Raises**:
        :py:exc:`ZenException`: if a node could not be added.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="compact"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">compact</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Compact the graph in place.  This will re-assign:

        #. node indices such that there are no unallocated node indices less than self.max_node_idx
        #. edge indices such that there are no unallocated edge indices less than self.max_edge_idx
        
.. note:: At present no way is provided of keeping track of the changes made to node and edge indices.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="copy"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">copy</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Create a copy of this graph.  

.. note:: that node and edge indices are preserved in this copy.

**Returns**: 
        :py:class:`zen.Graph`. A new graph object that contains an independent copy of the connectivity of this graph.  
        Node objects and node/edge data in the new graph reference the same objects as in the old graph.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="edges"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">edges</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return a list of edges in the graph.

By default, the list will contain all edges in the graph, each
edge as the tuple ``(u,v)``, where ``u`` and ``v`` are (node object) endpoints of the edge.

**Args**:

        * ``nobj [=None]``: if ``nobj`` is specified (not ``None``), then only the edges touching the node with 
                object ``nobj`` are included in the list.

        * ``data [=False]`` (boolean): if ``True``, then the data object associated with the edge
                is added into the tuple returned for each edge (e.g., ``(u,v,d)``).

        * ``weight [=False]`` (boolean):        if ``True``, then the weight of the edge is added
                into the tuple returned for each edge (e.g., ``(u,v,w)`` or ``(u,v,data,w)`` depending on the 
                value of the ``data`` argument).
        
Consider the following code which shows some of the different usages::

        G = Graph()
        G.add_edge(1,2,data='e1')
        G.add_edge(2,3,data='e2')
        G.add_edge(3,1,data='e3')

        print len(G.edges()) # this prints 3 - there are 3 edges in the graph
        print len(G.edges(1)) # this prints 2 - there are 2 edges attached to node 1

        # this will print the endpoints and data for all edges in the graph
        for u,v,data in G.edges(data=True):
                print u,v,data
        
        # this will print the endpoints and data for all edges in the graph
        for u,v,w in G.edges(weight=True):
                print u,v,data

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="edges_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">edges_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return a ``numpy.ndarray`` containing edges in the graph.

By default, the return value is a 1D array, ``R``, that contains all edges in the graph, where ``R[i]`` is
an edge index.

**Args**:

        * ``nidx [=-1]`` (int): if ``nidx`` is specified (``&gt;= 0``), then only the edges touching the node with 
                index ``nidx`` are included in the array returned.

        * ``data [=False]`` (boolean): if ``True``, then the array will no longer be a 1D array.  A separate column will be added
                such that ``R[i,0]`` is the edge index and ``R[i,1]`` is the data object associated with the edge.

        * ``weight [=False]`` (boolean):        if ``True``, then the array will no longer be a 1D array.  A separate column will be added
                such that ``R[i,0]`` is the edge index and ``R[i,1]`` is the weight of the edge.
                
When additional columns are added, they will always be in the order edge index, data, weight. 
Consider the following code which shows some of the different usages::

        G = Graph()
        G.add_edge(1,2,data='e1')
        G.add_edge(2,3,data='e2')
        G.add_edge(3,1,data='e3')

        print G.edges_().shape # this prints (3,) - there are 3 edges in the graph and 1 column
        print G.edges_(G.node_idx(1)).shape # this prints (2,) - there are 2 edges attached to node 1

        # this will print the endpoints and data for all edges in the graph
        print G.edges_(data=True).shape # this prints (3,2)
        print G.edges_(weight=True).shape # this prints (3,2)
        print G.edges_(data=True,weight=True).shape # this prints (3,3)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="edges_iter"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">edges_iter</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an iterator over edges in the graph.

By default, the iterator will cover all edges in the graph, returning each
edge as the tuple ``(u,v)``, where ``u`` and ``v`` are (node object) endpoints of the edge.

**Args**:
        
        * ``nobj [=None]``: if ``nobj`` is specified (not ``None``), then the edges touching the node with 
                object ``nobj`` are iterated over.

        * ``data [=False]`` (boolean): if ``True``, then the iterator adds object associated with the edge
                into the tuple returned (e.g., ``(u,v,d)``).

        * ``weight [=False]`` (boolean):        if ``True``, then the iterator adds the weight of the edge
                into the tuple returned (e.g., ``(u,v,w)`` or ``(u,v,data,w)`` depending on the value of the ``data`` argument).
                
Consider the following code which shows some of the different usages::

        G = Graph()
        G.add_edge(1,2,data='e1')
        G.add_edge(2,3,data='e2')
        G.add_edge(3,1,data='e3')

        print len(list(G.edges_iter())) # this prints 3 - there are 3 edges in the graph
        print len(list(G.edges_iter(1))) # this prints 2 - there are 2 edges attached to node 1
        
        # this will print the endpoints and data for all edges in the graph
        for u,v,data in G.edges_iter(data=True):
                print u,v,data
                
        # this will print the endpoints and data for all edges in the graph
        for u,v,w in G.edges_iter(weight=True):
                print u,v,data

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="edges_iter_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">edges_iter_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an iterator over edges in the graph.

By default, the iterator will cover all edges in the graph, returning each
edge as the edge index.

**Args**:
        
        * ``nidx [=-1]`` (int): if ``nidx`` is specified (``&gt;= 0``), then the edges touching the node with 
                index ``nidx`` are iterated over.

        * ``data [=False]`` (boolean): if ``True``, then the iterator returns a tuple containing the edge index
                and the data associated with the edge (e.g., ``(eidx,d)``).

        * ``weight [=False]`` (boolean):        if ``True``, then the iterator  returns a tuple containing the edge index
                and the weight of the edge (e.g., ``(eidx,w)`` or ``(eidx,d,w)`` depending on the value of the ``data`` argument).
                        
Consider the following code which shows some of the different usages::

        G = Graph()
        G.add_edge(1,2,data='e1')
        G.add_edge(2,3,data='e2')
        G.add_edge(3,1,data='e3')

        print len(list(G.edges_iter_())) # this prints 3 - there are 3 edges in the graph
        print len(list(G.edges_iter_(G.node_idx(1)))) # this prints 2 - there are 2 edges attached to node 1

        # this will print the endpoints and data for all edges in the graph
        for eidx,data in G.edges_iter_(data=True):
                print eidx,data
                
        # this will print the endpoints and data for all edges in the graph
        for eidx,w in G.edges_iter_(weight=True):
                print eidx,w                                    

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="endpoint"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">endpoint</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the object for the node (not u) that is the endpoint of this edge.

.. note::
        For performance reasons, no check is done to ensure that u is an endpoint of the edge.
        
**Args**:

        * ``eidx`` (int): a valid edge index.
        * ``u``: the object for one endpoint of the edge with index ``eidx``.
        
**Returns**:
        ``object``. The object for the node that is the other endpoint of edge ``eidx``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="endpoint_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">endpoint_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the index for the node (not u) that is the endpoint of this edge.

.. note::
        For performance reasons, no check is done to ensure that u is an endpoint of the edge.

**Args**:

        * ``eidx`` (int): a valid edge index.
        * ``u`` (int): the index for one endpoint of the edge with index ``eidx``.

**Returns**:
        ``integer``. The index for the node that is the other endpoint of edge ``eidx``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="from_adj_matrix"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">from_adj_matrix</span>(<span class="sig-arg">...</span>)</span>
    <br /><em class="fname">Static Method</em>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Create a new :py:class:`Graph` from adjacency matrix information
contained in ``M``.  ``M`` can be a ``numpy.matrix`` or
``numpy.ndarray`` with 2 dimensions.

**Keyword Args**:

  * ``node_obj_fxn [=int]`` (python function): The function that will be used to create
    node objects from the node indices.  If ``None``, then no node objects will be created.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="grp_edges_iter"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">grp_edges_iter</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an iterator over the edges of a group of nodes.  

By default, the iterator will return each edge as the tuple ``(u,v)``, where ``u`` and ``v`` are (node object) endpoints of the edge.

**Args**:

        * ``nbunch``: an iterable (usually a list) that yields node objects.  These are
                the nodes whose incident edges the iterator will return.
        
        * ``data [=False]`` (boolean): if ``True``, then the iterator adds object associated with the edge
                into the tuple returned (e.g., ``(u,v,d)``).

        * ``weight [=False]`` (boolean):        if ``True``, then the iterator adds the weight of the edge
                into the tuple returned (e.g., ``(u,v,w)`` or ``(u,v,data,w)`` depending on the value of the ``data`` argument).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="grp_edges_iter_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">grp_edges_iter_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an iterator over edges incident to some nodes in the graph.

By default, the iterator will return each edge as the edge index.

**Args**:
        
        * ``nbunch``: an iterable (usually a list) that yields node indices.  These are
                the nodes whose originating edges the iterator will return.

        * ``data [=False]`` (boolean): if ``True``, then the iterator returns a tuple containing the edge index
                and the data associated with the edge (e.g., ``(eidx,d)``).

        * ``weight [=False]`` (boolean):        if ``True``, then the iterator  returns a tuple containing the edge index
                and the weight of the edge (e.g., ``(eidx,w)`` or ``(eidx,d,w)`` depending on the value of the ``data`` argument).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="grp_neighbors_iter"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">grp_neighbors_iter</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an iterator over a group of nodes' immediate neighbors.

By default, the iterator will yield the node object for each immediate neighbor of nodes in ``nbunch``.

**Args**:

        * ``nbunch``: an iterable providing the node object over whose neighbors to iterate.

        * ``data [=False]`` (boolean): if ``True``, then a tuple is yielded (rather than a node object) 
                containing the node     object and the data object associated with the node (e.g., ``(n,d)``).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="grp_neighbors_iter_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">grp_neighbors_iter_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an iterator over a group of nodes' immediate neighbors.

By default, the iterator will yield the node index for each immediate neighbor of nodes in the iterable ``nbunch``.

**Args**:

        * ``nbunch``: an iterable providing the node indices over whose neighbors to iterate.

        * ``obj [=False]`` (boolean): if ``True``, then a tuple is yielded (rather than a node index) 
                containing the node     index and the node object associated with the node (e.g., ``(nidx,n)``).
        
        * ``data [=False]`` (boolean): if ``True``, then a tuple is yielded (rather than a node index) 
                containing the node     index and the data object associated with the node (e.g., ``(nidx,d)`` or ``(nidx,n,d)``
                depending on the value of the ``nobj`` argument).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="has_edge"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">has_edge</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return ``True`` if the graph contains an edge between ``u`` and ``v`` 
  (node objects). If either node object is not in the graph, this method 
  returns ``False``.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="has_edge_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">has_edge_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return ``True`` if the graph contains an edge between ``u`` and ``v`` (node indices).

**Raises**:
        :py:exc:`ZenException`: if either ``u`` or ``v`` are invalid node indices.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="is_compact"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">is_compact</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return ``True`` if the graph is in compact form.</p>
  <p>A graph is compact if there are no unallocated node or edge indices. 
  The graph can be compacted by calling the :py:meth:`Graph.compact` 
  method.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="matrix"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">matrix</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Construct and return the adjacency matrix.

**Returns**: 
        ``np.ndarray[double,ndims=2]``, ``M``.  The topology of the graph in adjacency matrix form where ``M[i,j]`` is the
        weight of the edge between nodes with index ``i`` and ``j``.  If there is no edge between ``i`` and ``j``, then 
        ``M[i,j] = 0``.
                
                When using this function, keep in mind that
                if the graph is not compact, there may be some node indices that don't correspond to valid nodes. 
                In this case, the corresponding matrix elements are not valid.  For example::
                
                        G = Graph()
                        G.add_node('a') # this node has index 0
                        G.add_node('b') # this node has index 1
                        G.add_node('c') # this node has index 2
                        
                        G.rm_node('b') # after this point, index 1 doesn't correspond to a valid node
                        
                        M = G.matrix() # M is a 3x3 matrix
                        
                        V = M[1,:] # the values in V are meaningless because a node with index 1 doesn't exist
                        
                This situation can be resolved by making a call to :py:meth:`Graph.compact` prior to calling this function::
                
                        G = Graph()
                        G.add_node('a') # this node has index 0
                        G.add_node('b') # this node has index 1
                        G.add_node('c') # this node has index 2
                
                        G.rm_node('b') # after this point, index 1 doesn't correspond to a valid node
                        
                        G.compact() 
                        # In the call above, we've reassigned node indices so that there are no invalid nodes
                        # this means that nodes 'a' and 'b' have been assigned indices 0 and 1.
                        
                        M = G.matrix() # M is a 2x2 matrix
                
                        V = M[1,:] # this is valid now and corresponds to node G.node_object(1)
                        

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="neighbors"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">neighbors</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return a list of a node's immediate neighbors.

By default, the list will contain the node object for each immediate neighbor of ``nobj``.

**Args**:

        * ``nobj``: this is the node object identifying the node whose neighbors to retrieve.

        * ``data [=False]`` (boolean): if ``True``, then a tuple is returned containing the node
                object and the data object associated with the node (e.g., ``(n,d)``).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="neighbors_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">neighbors_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an ``numpy.ndarray`` containing a node's immediate neighbors.

By default, the return value will be a 1D array containing the node index for each immediate neighbor of ``nidx``.

**Args**:

        * ``nidx``: this is the node index identifying the node whose neighbors to retrieve.

        * ``obj [=False]`` (boolean): if ``True``, then a 2D array, ``R`` is returned in which ``R[i,0]`` is the index
                of the neighbor and ``R[i,1]`` is the node object associated with it.

        * ``data [=False]`` (boolean): if ``True``, then a 2D array, ``R``, is returned with the final column containing the
                data object associated with the neighbor (e.g., ``R[i,0]`` is the index of the neighbor and ``R[i,1]`` or ``R[i,2]``
                is the data object, depending on the value of the ``nobj`` argument).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="neighbors_iter"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">neighbors_iter</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an iterator over a node's immediate neighbors.

By default, the iterator will yield the node object for each immediate neighbor of ``nobj``.

**Args**:

        * ``nobj``: this is the node object identifying the node whose neighbors to iterate over.

        * ``data [=False]`` (boolean): if ``True``, then a tuple is returned (rather than a node object) 
                containing the node     object and the data object associated with the node (e.g., ``(n,d)``).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="neighbors_iter_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">neighbors_iter_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an iterator over a node's immediate neighbors.

By default, the iterator will yield the node index for each immediate neighbor of ``nidx``.

**Args**:

        * ``nidx``: this is the node index identifying the node whose neighbors to iterate over.

        * ``obj [=False]`` (boolean): if ``True``, then a tuple is returned (rather than a node index) 
                containing the node     index and the node object associated with the node (e.g., ``(nidx,n)``).
                
        * ``data [=False]`` (boolean): if ``True``, then a tuple is returned (rather than a node index) 
                containing the node     index and the data object associated with the node (e.g., ``(nidx,d)`` or ``(nidx,n,d)``
                depending on the value of the ``nobj`` argument).

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="node_object"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">node_object</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the object associated with node having index ``nidx``.  If no 
  object is associated, then ``None`` is returned.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nodes"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nodes</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return a list of the node objects in the graph.</p>
  <p>.. note:</p>
<pre class="literalblock">
       This method is only valid for graphs in which all nodes have a node object.
</pre>
  <p>By default, the list contains node objects for all nodes.  If ``data``
  is ``True``, then the list contains tuples containing the node object and
  associated data.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nodes_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nodes_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return a numpy array of the nodes.</p>
  <p>By default, the array is 1-D and contains only node indices.  If 
  either ``obj`` or ``data`` are ``True``, then the result is a 2-D matrix 
  in which the additional columns contain the node object and/or data.</p>
  <p>.. note:</p>
<pre class="literalblock">
       If ``obj`` and ``data`` are both ``False``, then the numpy array returned has type ``int``.  When used
       with cython, this fact can be used to dramatically increase the speed of code iterating
       over a graph's nodes.
</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nodes_iter"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nodes_iter</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return an iterator over all the nodes in the graph.</p>
  <p>By default, the iterator yields node objects.  If ``data`` is 
  ``True``, then the iterator yields tuples 
  ``(node_object,node_data)``.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nodes_iter_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nodes_iter_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return an iterator over all the nodes in the graph.</p>
  <p>By default, the iterator yields node indices.  If either ``obj`` or 
  ``data`` are ``True``, then tuples are yielded.  For example:</p>
<pre class="literalblock">
       for nidx in G.node_iter_():
               print 'Node index:',nidx
               
       for nidx,obj in G.node_iter_(obj=True):
               print 'Node index:',nidx,'Node object:',obj
               
       for nidx,obj,data in G.node_iter_(True,True):
               print nidx,obj,data
</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rm_edge"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rm_edge</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Remove the edge between node objects ``u`` and ``v``.

**Raises**:
        
        * :py:exc:`ZenException`: if the edge index is invalid.
        * :py:exc:`KeyError`: if the node objects are invalid.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rm_edge_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rm_edge_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Remove the edge with index ``eidx``.

**Raises**:
        :py:exc:`ZenException`: if ``eid`` is an invalid edge index.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rm_node"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rm_node</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Remove the node associated with node object ``nobj``.  Any edges 
  incident to the node are also removed from the graph.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rm_node_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rm_node_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Remove the node with index ``nidx``. Any edges incident to the node 
  are also removed from the graph.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_edge_data"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_edge_data</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Associate a data object with the edge between nodes ``u`` and ``v`` 
  (node objects).</p>
  <p>The value of ``data`` will replace any data object currently 
  associated with the edge. If data is None, then any data associated with 
  the edge is deleted.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_edge_data_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_edge_data_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Associate a data object with the edge with index ``eidx``.</p>
  <p>The value of ``data`` will replace any data object currently 
  associated with the edge. If data is None, then any data associated with 
  the edge is deleted.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_node_data"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_node_data</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Associate a new data object with a specific node in the network.
If data is None, then any data associated with the node is deleted.

**Args**:

        * ``nobj``: the node object identifying the node whose data association is being changed.
        * ``data``: the data object to associate.  If ``None``, then any data object currently
                associated with this node will be deleted.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_node_data_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_node_data_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Associate a new data object with a specific node in the network.
If data is None, then any data associated with the node is deleted.

**Args**:

        * ``nidx``: the index of the node whose data association is being changed.
        * ``data``: the data object to associate.  If ``None``, then any data object currently
                associated with this node will be deleted.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_node_object"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_node_object</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Change the node object associated with a specific node.  

.. note::
        The new object must be unique among all other node objects.
        
**Args**:

        * ``curr_node_obj``: the current node object to change.
        * ``new_node_obj``: the object to replace the current node object with.
        
**Raises**:
        :py:exc:`ZenException`: if the new key object is not unique in the graph.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_node_object_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_node_object_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Change the node object associated with a specific node.  

.. note::
        The new object must be unique among all other node objects.

**Args**:

        * ``node_idx``: the index of the node to set the object for.
        * ``new_node_obj``: the object to replace the current node object with.

**Raises**:
        :py:exc:`ZenException`: if the new key object is not unique in the graph.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="validate"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">validate</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Checks whether the graph structure is valid.

This method inspects various invariants and conditions that should be present 
in order for the graph structure to be correct.  If any conditions are
broken, an exception will be raised immediately.

**KwArgs**:
        
        * ``verbose [=False]`` (boolean): print debugging information out before each condition check

**Raises**: 
        ``AssertionError``: if a condition isn't satisfied.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="zen-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://www.ruthsresearch.org/static/zen/pydoc">Zen</a></th>
          </tr></table></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1 on Sat Mar 14 14:30:07 2015
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
