<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>zen.algorithms.shortest_path</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="zen-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://www.ruthsresearch.org/static/zen/pydoc">Zen</a></th>
          </tr></table></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="zen-module.html">Package&nbsp;zen</a> ::
        <a href="zen.algorithms-module.html">Package&nbsp;algorithms</a> ::
        Module&nbsp;shortest_path
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options">[<a href="javascript:void(0);" class="privatelink"
    onclick="toggle_private();">hide&nbsp;private</a>]</span></td></tr>
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="zen.algorithms.shortest_path-module.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module shortest_path</h1><p class="nomargin-top"></p>
<pre class="literalblock">

The ``zen.algorithms.shortest_path`` module provides a number of functions for finding shortest paths in 
directed and undirected graphs.  All functions are available by importing the root-level ``zen`` package.

Functions return either paths or path lenghts.  These are distinguished by the end of their function name:

        * ``&lt;method_name&gt;_path`` and ``&lt;method_name&gt;_path_`` return paths.
        * ``&lt;method_name&gt;_path_length`` and ``&lt;method_name&gt;_path_length_`` return path lengths.
        
Functions also compute either the path from one node to all other nodes (single-source) or from all nodes to all other nodes
(all-pairs).  These functions are distinguished from one another by the beginning of their function name:

        * In general, ``&lt;method_name&gt;*`` compute single-source shortest paths.
        * In general, ``all_pairs_&lt;method_name&gt;*`` compute all-pairs shortest paths.
        
The exceptions to the rules above are the ``floyd_warshall`` functions which only compute all-pairs shortest paths.

Convenience functions are also provided for converting predecessor arrays returned by shortest path functions into lists 
of nodes.

Single-source shortest path functions
-------------------------------------

Single-source shortest path functions return either a dictionary or 1D numpy arrays.

        * If the function called operates on the node object-level, then a dictionary, ``D``, is returned
          where ``D[n]`` is the shortest path information for the node with object ``n``.
                * If the function returns path lengths, then ``D[n]`` will contain the path length from the source node
                  to ``n``.
                * If the function returns paths, then ``D[n]`` will contain a tuple ``(d,p)`` where ``d`` is the distance
                  from the source to ``n`` and ``p`` is the predecessor node object on the path from the source to ``n``.
        * If the function called operates on the node index-level, then 1D numpy arrays are returned.
                * If the function returns path lengths, then one numpy array, ``D``, is returned where ``D[i]`` is the
                  distance from the source node to the node with index ``i``.
                * If the function returns paths, then two numpy arrays, ``D`` and ``P``, are returned containing distance
                  and predecessor information, respectively.  ``D[i]`` holds the distance from the source node to the node
                  with index ``i`` (as in the case above) and ``P[i]`` holds the index of the predecessor node on the path leading
                  from the source node to the node with index ``i``.
                
.. note::
        Note that if numpy arrays are returned and your graph is not compact, some entries in the numpy array may be invalid.  If,
        for example, there is no nodes with index ``8``, then ``D[8]`` will contain an indeterminate value.  Besides the presence
        of indeterminiate entries, this can produce a small hit to performance and memory-efficiency since arrays must be created
        that are larger than the number of nodes in the network.

.. autofunction:: single_source_shortest_path(G,source,target=None)

.. autofunction:: single_source_shortest_path_(G,source,target=-1)

.. autofunction:: single_source_shortest_path_length(G,source,target=None)

.. autofunction:: single_source_shortest_path_length_(G,source,target=-1)

.. autofunction:: dijkstra_path(G,source,target=None,ignore_weights=False)

.. autofunction:: dijkstra_path_(G,source,target=-1,ignore_weights=False)

.. autofunction:: dijkstra_path_length(G,source,target=None,ignore_weights=False)

.. autofunction:: dijkstra_path_length_(G,source,target=-1,ignore_weights=False)

.. autofunction:: bellman_ford_path(G,source,ignore_weights=False)

.. autofunction:: bellman_ford_path_(G,source,ignore_weights=False)

.. autofunction:: bellman_ford_path_length(G,source,ignore_weights=False)

.. autofunction:: bellman_ford_path_length_(G,source,ignore_weights=False)

All-pairs shortest path functions
---------------------------------

All-pairs shortest path functions return either a dictionary or 2D numpy arrays.

        * If the function called operates on the node object-level, then a dictionary, ``D``, is returned
          where ``D[x][y]`` is the shortest path information for the path starting at node ``x`` and ending at node ``y``.
                * If the function returns path lengths, then ``D[x][y]`` will contain the path length from ``x`` to ``y``.
                * If the function returns paths, then ``D[x][y]`` will contain a tuple ``(d,p)`` where ``d`` is the distance
                  from ``x`` to ``y`` and ``p`` is the predecessor node object on the path from ``x`` to ``y``.
        * If the function called operates on the node index-level, then 1D numpy arrays are returned.
                * If the function returns path length, then one numpy array, ``D``, is returned where ``D[i]`` is the
                  distance from the source node to the node with index ``i``.
                * If the function returns paths, then two numpy arrays, ``D`` and ``P``, are returned containing distance
                  and predecessor information, respectively.  ``D[i]`` holds the distance from the source node to the node
                  with index ``i`` (as in the case above) and ``P[i]`` holds the index of the predecessor node on the path leading
                  from the source node to the node with index ``i``.
                
.. note::
        Note that if numpy arrays are returned and your graph is not compact, some entries in the numpy arrays may be invalid.  If,
        for example, there is no nodes with index ``8``, then ``D[1,8]`` will contain an indeterminate value.  Besides the presence
        of indeterminiate entries, this can produce a small hit to performance and memory-efficiency since arrays must be created
        that are larger than the number of nodes in the network.

.. autofunction:: all_pairs_shortest_path(G,ignore_weights=False)

.. autofunction:: all_pairs_shortest_path_(G,ignore_weights=False)

.. autofunction:: all_pairs_shortest_path_length(G,ignore_weights=False)

.. autofunction:: all_pairs_shortest_path_length_(G,ignore_weights=False)

.. autofunction:: all_pairs_dijkstra_path(G,ignore_weights=False)

.. autofunction:: all_pairs_dijkstra_path_(G,ignore_weights=False)

.. autofunction:: all_pairs_dijkstra_path_length(G,ignore_weights=False)

.. autofunction:: all_pairs_dijkstra_path_length_(G,ignore_weights=False)

.. autofunction:: all_pairs_bellman_ford_path(G,ignore_weights=False)

.. autofunction:: all_pairs_bellman_ford_path_(G,ignore_weights=False)

.. autofunction:: all_pairs_bellman_ford_path_length(G,ignore_weights=False)

.. autofunction:: all_pairs_bellman_ford_path_length_(G,ignore_weights=False)

Converting from predecessors to paths
-------------------------------------

Two functions are provided for converting the predecessor dictionaries and arrays/matrices returned by the shortest-path methods
into actual paths.

.. autofunction:: pred2path(source,target,R)

.. autofunction:: pred2path_(source,target,P)

</pre>

<!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Functions</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Functions"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_bellman_ford_path" class="summary-sig-name">all_pairs_bellman_ford_path</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the Bellman-Ford algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_bellman_ford_path_" class="summary-sig-name">all_pairs_bellman_ford_path_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the Bellman-Ford algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_bellman_ford_path_length" class="summary-sig-name">all_pairs_bellman_ford_path_length</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_bellman_ford_path_length_" class="summary-sig-name">all_pairs_bellman_ford_path_length_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_dijkstra_path" class="summary-sig-name">all_pairs_dijkstra_path</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using Dijkstra's algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_dijkstra_path_" class="summary-sig-name">all_pairs_dijkstra_path_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using Dijkstra's algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_dijkstra_path_length" class="summary-sig-name">all_pairs_dijkstra_path_length</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_dijkstra_path_length_" class="summary-sig-name">all_pairs_dijkstra_path_length_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_shortest_path" class="summary-sig-name">all_pairs_shortest_path</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the algorithm described in :py:func:`single_source_shortest_path`.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_shortest_path_" class="summary-sig-name">all_pairs_shortest_path_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the algorithm described in :py:func:`single_source_shortest_path`.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_shortest_path_length" class="summary-sig-name">all_pairs_shortest_path_length</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the algorithm descibed in :py:func:`single_source_shortest_path`.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#all_pairs_shortest_path_length_" class="summary-sig-name">all_pairs_shortest_path_length_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the algorithm described in :py:func:`single_source_shorest_path`.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#bellman_ford_path" class="summary-sig-name">bellman_ford_path</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest path using the Bellman-Ford algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#bellman_ford_path_" class="summary-sig-name">bellman_ford_path_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest paths using the Bellman-Ford algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#bellman_ford_path_length" class="summary-sig-name">bellman_ford_path_length</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest path lengths using the Bellman-Ford algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#bellman_ford_path_length_" class="summary-sig-name">bellman_ford_path_length_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest path lengths in an unweighted network by trading space for speed.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="dijkstra_cmp"></a><span class="summary-sig-name">dijkstra_cmp</span>(<span class="summary-sig-arg">...</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#dijkstra_path" class="summary-sig-name">dijkstra_path</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest path using the Dijkstra algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#dijkstra_path_" class="summary-sig-name">dijkstra_path_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest paths using Dijkstra's algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#dijkstra_path_length" class="summary-sig-name">dijkstra_path_length</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest path lengths using Dijkstra's algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#dijkstra_path_length_" class="summary-sig-name">dijkstra_path_length_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest path lengths using Dijkstra's algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="flag_unreachable"></a><span class="summary-sig-name">flag_unreachable</span>(<span class="summary-sig-arg">...</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#floyd_warshall_d_" class="summary-sig-name" onclick="show_private();">floyd_warshall_d_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Floyd-Warshall algorithm for directed graphs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#floyd_warshall_path" class="summary-sig-name">floyd_warshall_path</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#floyd_warshall_path_" class="summary-sig-name">floyd_warshall_path_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#floyd_warshall_path_length" class="summary-sig-name">floyd_warshall_path_length</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#floyd_warshall_path_length_" class="summary-sig-name">floyd_warshall_path_length_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#floyd_warshall_u_" class="summary-sig-name" onclick="show_private();">floyd_warshall_u_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Floyd-Warshall algorithm for directed graphs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#pred2path" class="summary-sig-name">pred2path</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Construct a shortest path from ``source`` to ``target`` using the output of a shortest path
function.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#pred2path_" class="summary-sig-name">pred2path_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Construct a shortest path from ``source`` to ``target`` using the output of a shortest path
function.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#single_source_shortest_path" class="summary-sig-name">single_source_shortest_path</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest paths in an unweighted network by trading space for speed.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#single_source_shortest_path_" class="summary-sig-name">single_source_shortest_path_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest paths in an unweighted network by trading space for speed.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="single_source_shortest_path_d_"></a><span class="summary-sig-name">single_source_shortest_path_d_</span>(<span class="summary-sig-arg">...</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#single_source_shortest_path_length" class="summary-sig-name">single_source_shortest_path_length</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest path lengths in an unweighted network by trading space for speed.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="zen.algorithms.shortest_path-module.html#single_source_shortest_path_length_" class="summary-sig-name">single_source_shortest_path_length_</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Computes the single source shortest path lengths in an unweighted network by trading space for speed.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="single_source_shortest_path_u_"></a><span class="summary-sig-name">single_source_shortest_path_u_</span>(<span class="summary-sig-arg">...</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== VARIABLES ==================== -->
<a name="section-Variables"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Variables</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Variables"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__package__"></a><span class="summary-name">__package__</span> = <code title="'zen.algorithms'"><code class="variable-quote">'</code><code class="variable-string">zen.algorithms</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="zen.algorithms.shortest_path-module.html#__pyx_capi__" class="summary-name" onclick="show_private();">__pyx_capi__</a> = <code title="{'all_pairs_bellman_ford_path': &lt;capsule object &quot;PyObject *(PyObject *\
, int __pyx_skip_dispatch, struct __pyx_opt_args_3zen_10algorithms_13s\
hortest_path_all_pairs_bellman_ford_path *__pyx_optional_args)&quot; at 0x1\
0bedc030&gt;,
 'all_pairs_bellman_ford_path_': &lt;capsule object &quot;PyObject *(PyObject \
*, int __pyx_skip_dispatch, struct __pyx_opt_args_3zen_10algorithms_13\
shortest_path_all_pairs_bellman_ford_path_ *__pyx_optional_args)&quot; at 0\
x10bedc090&gt;,
..."><code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">all_pairs_bellman_ford_path</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;capsule object<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__test__"></a><span class="summary-name">__test__</span> = <code title="{}"><code class="variable-group">{</code><code class="variable-group">}</code></code>
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Function Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-FunctionDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="all_pairs_bellman_ford_path"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_bellman_ford_path</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the Bellman-Ford algorithm.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        * :py:class:`dict`, ``R``. ``R[x][y]`` is a tuple ``(d,p)`` where ``d`` is the distance of node ``y``
          from node ``x`` and ``p`` is the predecessor of node ``y`` on the path from ``x`` to ``y``. 

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all_pairs_bellman_ford_path_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_bellman_ford_path_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the Bellman-Ford algorithm.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        2D ``numpy.ndarray``, ``D`` and ``P``. ``D`` is the distance matrix where ``D[i,j]`` is the 
        length of the shortest path from node with index i to the node with index j.  ``P`` is the predecessor
        matrix where ``P[i,j]`` is the node preceeding ``j on a shortest path from ``i`` to ``j``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all_pairs_bellman_ford_path_length"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_bellman_ford_path_length</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.

**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        * :py:class:`dict`, ``D``. ``D[x][y]`` is the distance of node ``y`` from node ``x``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all_pairs_bellman_ford_path_length_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_bellman_ford_path_length_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        2D ``numpy.ndarray``, ``D``. ``D`` is the distance matrix where ``D[i,j]`` is the 
        length of the shortest path from node with index i to the node with index j.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all_pairs_dijkstra_path"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_dijkstra_path</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using Dijkstra's algorithm.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        * :py:class:`dict`, ``R``. ``R[x][y]`` is a tuple ``(d,p)`` where ``d`` is the distance of node ``y``
          from node ``x`` and ``p`` is the predecessor of node ``y`` on the path from ``x`` to ``y``. 

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all_pairs_dijkstra_path_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_dijkstra_path_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using Dijkstra's algorithm.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        2D ``numpy.ndarray``, ``D`` and ``P``. ``D`` is the distance matrix where ``D[i,j]`` is the 
        length of the shortest path from node with index i to the node with index j.  ``P`` is the predecessor
        matrix where ``P[i,j]`` is the node preceeding ``j on a shortest path from ``i`` to ``j``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all_pairs_dijkstra_path_length"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_dijkstra_path_length</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.

**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        * :py:class:`dict`, ``D``. ``D[x][y]`` is the distance of node ``y`` from node ``x``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all_pairs_dijkstra_path_length_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_dijkstra_path_length_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        2D ``numpy.ndarray``, ``D``. ``D`` is the distance matrix where ``D[i,j]`` is the 
        length of the shortest path from node with index i to the node with index j.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all_pairs_shortest_path"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_shortest_path</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the algorithm described in :py:func:`single_source_shortest_path`.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.

**Returns**:
        * :py:class:`dict`, ``R``. ``R[x][y]`` is a tuple ``(d,p)`` where ``d`` is the distance of node ``y``
          from node ``x`` and ``p`` is the predecessor of node ``y`` on the path from ``x`` to ``y``. 

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all_pairs_shortest_path_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_shortest_path_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the algorithm described in :py:func:`single_source_shortest_path`.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.

**Returns**:
        2D ``numpy.ndarray``, ``D`` and ``P``. ``D`` is the distance matrix where ``D[i,j]`` is the 
        length of the shortest path from node with index i to the node with index j.  ``P`` is the predecessor
        matrix where ``P[i,j]`` is the node preceeding ``j on a shortest path from ``i`` to ``j``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all_pairs_shortest_path_length"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_shortest_path_length</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the algorithm descibed in :py:func:`single_source_shortest_path`.

**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.

**Returns**:
        * :py:class:`dict`, ``D``. ``D[x][y]`` is the distance of node ``y`` from node ``x``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all_pairs_shortest_path_length_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all_pairs_shortest_path_length_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the algorithm described in :py:func:`single_source_shorest_path`.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.

**Returns**:
        2D ``numpy.ndarray``, ``D``. ``D`` is the distance matrix where ``D[i,j]`` is the 
        length of the shortest path from node with index i to the node with index j.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="bellman_ford_path"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">bellman_ford_path</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest path using the Bellman-Ford algorithm.  

**Args**:

        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node object of the source node.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        :py:class:`dict`, ``D``, if ``target`` is ``None``. ``D[x]`` is a tuple ``(d,p)`` where ``d`` is the distance of node ``x``
        from the source and ``p`` is the predecessor of node ``x`` on the path to the source.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="bellman_ford_path_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">bellman_ford_path_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest paths using the Bellman-Ford algorithm.

**Args**:

        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node index of the source node.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        numpy ``ndarray``, ``D`` and ``P``.  ``D[i]`` is the distance of node with index ``i`` from the source.  ``P[i]``
        is the index of the immediate predecessor to node with index ``i`` on the path from the source node.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="bellman_ford_path_length"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">bellman_ford_path_length</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest path lengths using the Bellman-Ford algorithm.

**Args**:
        
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node object of the source node.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        :py:class:`dict`, ``D``, if ``target`` is ``None``. ``D[x]`` is the distance of node ``x`` from the source.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="bellman_ford_path_length_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">bellman_ford_path_length_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest path lengths in an unweighted network by trading space for speed.  

This algorithm requires several blocks of memory whose size are on the order of the number of 
nodes in the network.  Thus for very large networks, dijkstra's algorithm may be faster.

**Args**:
        
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node index of the source node.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        numpy ``ndarray``, ``D``.  ``D[i]`` is the distance of node with index ``i`` from the source.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="dijkstra_path"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dijkstra_path</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest path using the Dijkstra algorithm.

**Args**:

        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node object of the source node.
        * ``target [=None]``: the node object of the target node.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        The return value depends on the value of ``target``.
        
                * :py:class:`dict`, ``D``, if ``target`` is ``None``. ``D[x]`` is a tuple ``(d,p)`` where ``d`` is the distance of node ``x``
                  from the source and ``p`` is the predecessor of node ``x`` on the path to the source. 
                * :py:class:`list` if ``target`` is not ``None``.  In this case, the return value is the distance from 
                  source to target and the path from source to target, returned as a list of nodes along the path.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="dijkstra_path_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dijkstra_path_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest paths using Dijkstra's algorithm.

**Args**:

        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node index of the source node.
        * ``target [=None]``: the node index of the target node.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        numpy ``ndarray``, ``D`` and ``P``.  ``D[i]`` is the distance of node with index ``i`` from the source.  ``P[i]``
        is the index of the immediate predecessor to node with index ``i`` on the path from the source node.
        If the target is specified, the algorithm halts when the target node is reached.  In this case, 
        the distance and predecessor arrays will be partially completed.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="dijkstra_path_length"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dijkstra_path_length</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest path lengths using Dijkstra's algorithm.

**Args**:

        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node object of the source node.
        * ``target [=None]``: the node object of the target node.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        The return value depends on the value of ``target``.
        
                * :py:class:`dict`, ``D``, if ``target`` is ``None``. ``D[x]`` is the distance of node ``x`` from the source.
                * :py:class:`list` if ``target`` is not ``None``.  In this case, the return value is the distance from 
                  source to target and the path from source to target.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="dijkstra_path_length_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dijkstra_path_length_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest path lengths using Dijkstra's algorithm.

**Args**:

        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node index of the source node.
        * ``target [=None]``: the node index of the target node.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        numpy ``ndarray``, ``D``.  ``D[i]`` is the distance of node with index ``i`` from the source.
        If the target is specified, the algorithm halts when the target node is reached.  In this case, 
        the distance array will be partially completed.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="floyd_warshall_d_"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">floyd_warshall_d_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Floyd-Warshall algorithm for directed graphs.</p>
  <p>Return a distance matrix D where D[i,j] is the length of the shortest 
  path from node with index i to the node with index j.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="floyd_warshall_path"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">floyd_warshall_path</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        * :py:class:`dict`, ``R``. ``R[x][y]`` is a tuple ``(d,p)`` where ``d`` is the distance of node ``y``
          from node ``x`` and ``p`` is the predecessor of node ``y`` on the path from ``x`` to ``y``. 

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="floyd_warshall_path_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">floyd_warshall_path_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        2D ``numpy.ndarray``, ``D`` and ``P``. ``D`` is the distance matrix where ``D[i,j]`` is the 
        length of the shortest path from node with index i to the node with index j.  ``P`` is the predecessor
        matrix where ``P[i,j]`` is the node preceeding ``j on a shortest path from ``i`` to ``j``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="floyd_warshall_path_length"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">floyd_warshall_path_length</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.

**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        * :py:class:`dict`, ``D``. ``D[x][y]`` is the distance of node ``y`` from node ``x``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="floyd_warshall_path_length_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">floyd_warshall_path_length_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.
        
**Args**:
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        2D ``numpy.ndarray``, ``D``. ``D`` is the distance matrix where ``D[i,j]`` is the 
        length of the shortest path from node with index i to the node with index j.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="floyd_warshall_u_"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">floyd_warshall_u_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Floyd-Warshall algorithm for directed graphs.</p>
  <p>Return a distance matrix D where D[i,j] is the length of the shortest 
  path from node with index i to the node with index j.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="pred2path"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">pred2path</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Construct a shortest path from ``source`` to ``target`` using the output of a shortest path
function.

**Args**:
        * ``source``: the node object of the source node.
        * ``target``: the node object of the target node.
        * ``R`` (:py:class:`dict`): a dictionary returned by either a single-source or all-pairs shortest path function.
          This object must be returned by a function that computes the paths, not just the path *lengths*.
        
**Returns**:
        :py:class:`list`. The list of node objects of nodes encountered on a shortest path from ``source`` to ``target``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="pred2path_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">pred2path_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Construct a shortest path from ``source`` to ``target`` using the output of a shortest path
function.

**Args**:
        * ``source``: the index of the source node.
        * ``target``: the index of the target node.
        * ``P`` (:py:class:`numpy.ndarray`): a predecessor array or matrix returned by either a single-source or 
          all-pairs shortest path function.  This object must be returned by a function that computes 
          the paths, not just the path *lengths*.
        
**Returns**:
        :py:class:`list`. The list of indices of nodes encountered on a shortest path from ``source`` to ``target``.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="single_source_shortest_path"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">single_source_shortest_path</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest paths in an unweighted network by trading space for speed.  

This algorithm requires several blocks of memory whose size are on the order of the number of 
nodes in the network.  Thus for very large networks, dijkstra's algorithm may be faster.

**Args**:
        
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node object of the source node.
        * ``target [=None]``: the node object of the target node.

**Returns**:
        The return value depends on the value of ``target``.
                
                * :py:class:`dict`, ``D``, if ``target`` is ``None``. ``D[x]`` is a tuple ``(d,p)`` where ``d`` is the distance of node ``x``
                  from the source and ``p`` is the predecessor of node ``x`` on the path to the source. 
                * :py:class:`list` if ``target`` is not ``None``.  In this case, the return value is the distance from 
                  source to target and the path from source to target, returned as a list of nodes along the path.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="single_source_shortest_path_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">single_source_shortest_path_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest paths in an unweighted network by trading space for speed.  

This algorithm requires several blocks of memory whose size are on the order of the number of 
nodes in the network.  Thus for very large networks, dijkstra's algorithm may be faster.

**Args**:
        
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node index of the source node.
        * ``target [=None]``: the node index of the target node.

**Returns**:
        numpy ``ndarray``, ``D`` and ``P``.  ``D[i]`` is the distance of node with index ``i`` from the source.  ``P[i]``
        is the index of the immediate predecessor to node with index ``i`` on the path from the source node.
        If the target is specified, the algorithm halts when the target node is reached.  In this case, 
        the distance and predecessor arrays will be partially completed.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="single_source_shortest_path_length"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">single_source_shortest_path_length</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest path lengths in an unweighted network by trading space for speed.  

This algorithm requires several blocks of memory whose size are on the order of the number of 
nodes in the network.  Thus for very large networks, dijkstra's algorithm may be faster.

**Args**:
        
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node object of the source node.
        * ``target [=None]``: the node object of the target node.
        
**Returns**:
        The return value depends on the value of ``target``.
                
                * :py:class:`dict`, ``D``, if ``target`` is ``None``. ``D[x]`` is the distance of node ``x`` from the source.
                * :py:class:`list` if ``target`` is not ``None``.  In this case, the return value is the distance from 
                  source to target and the path from source to target.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="single_source_shortest_path_length_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">single_source_shortest_path_length_</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Computes the single source shortest path lengths in an unweighted network by trading space for speed.  

This algorithm requires several blocks of memory whose size are on the order of the number of 
nodes in the network.  Thus for very large networks, dijkstra's algorithm may be faster.

**Args**:
        
        * ``G`` (:py:class:`zen.Graph` and :py:class:`zen.DiGraph`): the graph to compute the shortest path on.
        * ``source``: the node index of the source node.
        * ``target [=None]``: the node index of the target node.
        * ``ignore_weights [=False]``: when ``True``, unit weight will be used for each edge rather than the edge's
          actual weight.

**Returns**:
        numpy ``ndarray``, ``D``.  ``D[i]`` is the distance of node with index ``i`` from the source.
        If the target is specified, the algorithm halts when the target node is reached.  In this case, 
        the distance array will be partially completed.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== VARIABLES DETAILS ==================== -->
<a name="section-VariablesDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Variables Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-VariablesDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="__pyx_capi__"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">__pyx_capi__</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
<code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">all_pairs_bellman_ford_path</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;capsule object &quot;PyObject *(PyObject *<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
, int __pyx_skip_dispatch, struct __pyx_opt_args_3zen_10algorithms_13s<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
hortest_path_all_pairs_bellman_ford_path *__pyx_optional_args)&quot; at 0x1<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
0bedc030&gt;<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">all_pairs_bellman_ford_path_</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;capsule object &quot;PyObject *(PyObject <span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
*, int __pyx_skip_dispatch, struct __pyx_opt_args_3zen_10algorithms_13<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
shortest_path_all_pairs_bellman_ford_path_ *__pyx_optional_args)&quot; at 0<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
x10bedc090&gt;<code class="variable-op">,</code>
<code class="variable-ellipsis">...</code>
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="zen-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://www.ruthsresearch.org/static/zen/pydoc">Zen</a></th>
          </tr></table></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1 on Sat Mar 14 14:30:07 2015
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
